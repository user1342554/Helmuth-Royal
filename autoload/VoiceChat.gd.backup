extends Node

# Voice settings
var voice_range := 18.0
var noise_gate_db := -60.0  # Less aggressive for better voice detection
var mic_gain := 1.5  # Boost input
var voice_volume := 1.5  # Boost output

# Audio settings (optimized for network)
var sample_rate := 32000  # Better quality default
var buffer_length := 0.01  # 10ms buffer
var recording := false

# Quality settings
var send_rate := 1  # Send every N frames (1 = every frame)

var audio_bus_idx := -1
var audio_effect: AudioEffectCapture
var voice_players := {}  # peer_id -> AudioStreamPlayer3D

# Performance optimization
var _frame_counter := 0
var _distance_check_counter := 0
var _distance_check_interval := 10  # Check distances every N frames
var _cached_nearby_peers := []

func _ready():
	# Setup audio capture bus
	audio_bus_idx = AudioServer.bus_count
	AudioServer.add_bus(audio_bus_idx)
	AudioServer.set_bus_name(audio_bus_idx, "VoiceCapture")
	AudioServer.set_bus_mute(audio_bus_idx, true)
	
	# Add capture effect
	_setup_audio_effect()
	
	# Setup microphone
	var idx = AudioServer.get_bus_index("Record")
	if idx == -1:
		idx = AudioServer.bus_count
		AudioServer.add_bus(idx)
		AudioServer.set_bus_name(idx, "Record")
		AudioServer.set_bus_send(idx, "VoiceCapture")
	
	# Set default quality (High = 32kHz)
	set_sample_rate(32000)
	
	print("VoiceChat initialized")

func _setup_audio_effect():
	# Remove old effect if exists
	if audio_effect:
		var effect_idx = AudioServer.get_bus_effect_count(audio_bus_idx)
		for i in range(effect_idx):
			AudioServer.remove_bus_effect(audio_bus_idx, 0)
	
	# Create new effect
	audio_effect = AudioEffectCapture.new()
	audio_effect.buffer_length = buffer_length
	AudioServer.add_bus_effect(audio_bus_idx, audio_effect)

func set_sample_rate(rate: int):
	sample_rate = rate
	
	# Restart recording to apply new settings
	var was_recording = recording
	if was_recording:
		stop_recording()
		await get_tree().create_timer(0.1).timeout
		start_recording()
	
	# Recreate all voice players with new sample rate
	var peers_to_recreate = voice_players.keys()
	for peer_id in peers_to_recreate:
		cleanup_voice_player(peer_id)
	
	await get_tree().create_timer(0.2).timeout
	
	for peer_id in peers_to_recreate:
		setup_voice_player(peer_id)
	
	print("Audio quality: Rate=%d Hz" % sample_rate)

func set_buffer_length(length: float):
	buffer_length = length
	_setup_audio_effect()
	print("Buffer length changed to: ", buffer_length)

func start_recording():
	if recording:
		return
	
	recording = true
	
	# Create microphone player
	var mic_player = AudioStreamPlayer.new()
	mic_player.stream = AudioStreamMicrophone.new()
	mic_player.bus = "Record"
	add_child(mic_player)
	mic_player.play()
	
	print("Voice recording started")

func stop_recording():
	recording = false
	
	# Remove microphone player
	for child in get_children():
		if child is AudioStreamPlayer:
			child.queue_free()
	
	if audio_effect:
		audio_effect.clear_buffer()
	
	print("Voice recording stopped")

func _process(_delta):
	if not recording or not audio_effect:
		return
	
	# Throttle audio sends based on quality
	_frame_counter += 1
	if _frame_counter < send_rate:
		return
	_frame_counter = 0
	
	# Check available frames
	var frames_available = audio_effect.get_frames_available()
	if frames_available == 0:
		return
	
	# Capture audio
	var audio_data = audio_effect.get_buffer(frames_available)
	if audio_data.size() == 0:
		return
	
	# Voice Activity Detection (simple RMS) - optimized
	var rms = calculate_rms_optimized(audio_data)
	var db = linear_to_db(rms) if rms > 0 else -100.0
	
	# Check noise gate (early return for performance)
	if db < noise_gate_db:
		return
	
	# Apply gain (optimized - only if needed)
	if mic_gain != 1.0:
		for i in range(audio_data.size()):
			audio_data[i] = audio_data[i] * mic_gain
	
	# Send to nearby players
	send_voice_packet(audio_data)

func calculate_rms_optimized(samples: PackedVector2Array) -> float:
	# Optimized RMS calculation with early return
	var size = samples.size()
	if size == 0:
		return 0.0
	
	var sum := 0.0
	# Process in chunks for better CPU cache usage
	for i in range(size):
		var mono = (samples[i].x + samples[i].y) * 0.5
		sum += mono * mono
	
	return sqrt(sum / size)

func calculate_rms(samples: PackedVector2Array) -> float:
	if samples.size() == 0:
		return 0.0
	
	var sum := 0.0
	for sample in samples:
		var mono = (sample.x + sample.y) * 0.5
		sum += mono * mono
	
	return sqrt(sum / samples.size())

func send_voice_packet(audio_data: PackedVector2Array):
	if not multiplayer.has_multiplayer_peer():
		return
	
	var local_player = NetworkManager.get_local_player()
	if not local_player:
		return
	
	# Update nearby peers
	_distance_check_counter += 1
	if _distance_check_counter >= _distance_check_interval:
		_distance_check_counter = 0
		_update_nearby_peers(local_player.global_position)
	
	if _cached_nearby_peers.is_empty():
		return
	
	# Compress audio - simple mono conversion
	var compressed = compress_audio(audio_data)
	
	# Check packet size - allow larger for quality
	if compressed.size() > 2048:
		# Packet too large, skip it
		return
	
	# Send to each nearby peer
	for peer_id in _cached_nearby_peers:
		# Validate peer exists before sending
		if NetworkManager.players.has(peer_id):
			receive_voice_packet.rpc_id(peer_id, compressed)

func _update_nearby_peers(local_pos: Vector3):
	# Update cached list of nearby peers
	_cached_nearby_peers.clear()
	var my_id = multiplayer.get_unique_id()
	
	for peer_id in NetworkManager.players.keys():
		if peer_id == my_id:
			continue
		
		var player = NetworkManager.get_player(peer_id)
		if player:
			# Use squared distance to avoid sqrt
			var distance_sq = local_pos.distance_squared_to(player.global_position)
			if distance_sq <= voice_range * voice_range:
				_cached_nearby_peers.append(peer_id)

func compress_audio(samples: PackedVector2Array) -> PackedByteArray:
	# Downsample to mono for bandwidth
	var mono_samples = PackedFloat32Array()
	mono_samples.resize(samples.size())
	
	for i in range(samples.size()):
		mono_samples[i] = (samples[i].x + samples[i].y) * 0.5
	
	# Convert to bytes
	return mono_samples.to_byte_array()

func decompress_audio(bytes: PackedByteArray) -> PackedVector2Array:
	# Convert from bytes to floats
	var mono_samples = bytes.to_float32_array()
	
	# Convert mono to stereo
	var samples = PackedVector2Array()
	samples.resize(mono_samples.size())
	
	for i in range(mono_samples.size()):
		var value = mono_samples[i]
		samples[i] = Vector2(value, value)
	
	return samples

@rpc("any_peer", "unreliable")
func receive_voice_packet(compressed: PackedByteArray):
	var sender_id = multiplayer.get_remote_sender_id()
	
	# Validate sender exists in game
	if not NetworkManager.players.has(sender_id):
		return
	
	# Get or create voice player
	if not voice_players.has(sender_id) or not is_instance_valid(voice_players.get(sender_id)):
		setup_voice_player(sender_id)
		# Wait a frame for player to be ready
		await get_tree().process_frame
		if not voice_players.has(sender_id):
			return
	
	var player_3d: AudioStreamPlayer3D = voice_players[sender_id]
	if not is_instance_valid(player_3d):
		return
	
	var playback: AudioStreamGeneratorPlayback = player_3d.get_stream_playback()
	if not playback:
		return
	
	# Decompress audio
	var samples = decompress_audio(compressed)
	
	# Apply volume
	if voice_volume != 1.0:
		for i in range(samples.size()):
			samples[i] = samples[i] * voice_volume
	
	# Push to playback (always push, buffer will handle it)
	playback.push_buffer(samples)

func setup_voice_player(peer_id: int):
	var player = NetworkManager.get_player(peer_id)
	if not player or not is_instance_valid(player):
		return
	
	# Don't create if already exists
	if voice_players.has(peer_id) and is_instance_valid(voice_players[peer_id]):
		return
	
	# Create AudioStreamGenerator with CURRENT sample rate
	var stream = AudioStreamGenerator.new()
	stream.mix_rate = sample_rate  # CRITICAL: Must match current sample_rate!
	stream.buffer_length = 0.2  # 200ms playback buffer
	
	# Create AudioStreamPlayer3D
	var player_3d = AudioStreamPlayer3D.new()
	player_3d.name = "VoicePlayer"
	player_3d.stream = stream
	
	# 3D audio settings
	player_3d.max_distance = voice_range * 2.0
	player_3d.unit_size = 1.0
	player_3d.attenuation_model = AudioStreamPlayer3D.ATTENUATION_INVERSE_DISTANCE
	player_3d.attenuation_filter_cutoff_hz = 20000  # No filtering
	player_3d.volume_db = 12.0  # High volume
	player_3d.autoplay = true
	
	player.add_child(player_3d)
	voice_players[peer_id] = player_3d
	
	print("Voice player created for peer %d at %d Hz" % [peer_id, sample_rate])

func cleanup_voice_player(peer_id: int):
	if voice_players.has(peer_id):
		var player_3d = voice_players[peer_id]
		if is_instance_valid(player_3d):
			player_3d.queue_free()
		voice_players.erase(peer_id)

